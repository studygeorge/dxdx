// backend/src/routes/investments.routes.ts

import { FastifyInstance } from 'fastify';
import { InvestmentsController } from '../controllers/investments.controller';
import { authenticateUser } from '../middleware/auth.middleware';
import { PrismaClient } from '@prisma/client';
import { 
  notifyEarlyWithdrawal, 
  notifyPartialWithdrawal,
  notifyUpgradeRequest
} from '../bot/telegram-bot';

const prisma = new PrismaClient();

export async function investmentsRoutes(app: FastifyInstance) {
  app.addHook('onRequest', authenticateUser);

  app.post('/create', InvestmentsController.createInvestment);
  app.get('/my', InvestmentsController.getMyInvestments);
  app.get('/:id', InvestmentsController.getInvestment);
  app.post('/:id/confirm', InvestmentsController.confirmPayment);
  app.delete('/:id', InvestmentsController.cancelInvestment);

  app.post('/:investmentId/confirm-payment', async (request, reply) => {
    try {
      const { investmentId } = request.params as { investmentId: string };
      const userId = request.currentUser!.id;

      const investment = await prisma.investment.findUnique({
        where: { id: investmentId },
        include: {
          user: { 
            select: { 
              id: true,
              username: true,
              email: true
            } 
          },
          plan: { select: { name: true } }
        }
      });

      if (!investment) {
        return reply.status(404).send({ 
          success: false,
          error: 'Investment not found' 
        });
      }

      if (investment.userId !== userId) {
        return reply.status(403).send({ 
          success: false,
          error: 'Access denied' 
        });
      }

      if (investment.status !== 'PENDING') {
        return reply.status(400).send({ 
          success: false,
          error: 'Investment is not in pending status' 
        });
      }

      const adminWalletConfig = await prisma.systemConfig.findUnique({
        where: { key: 'STAKING_WALLET_USDT_TRC20' }
      });

      const adminWallet = adminWalletConfig?.value || process.env.ADMIN_WALLET_ADDRESS || '';

      if (!adminWallet) {
        console.error('Admin wallet not configured');
        return reply.status(500).send({
          success: false,
          error: 'Admin wallet configuration missing'
        });
      }

      const BOT_USERNAME = process.env.TELEGRAM_BOT_USERNAME || 'dxcapital_bot';
      
      const ADMIN_CHAT_ID = process.env.ADMIN_CHAT_ID || process.env.SUPPORT_TELEGRAM_ID;

      if (!ADMIN_CHAT_ID) {
        console.error('ADMIN_CHAT_ID or SUPPORT_TELEGRAM_ID not configured');
        return reply.status(500).send({
          success: false,
          error: 'Admin notification not configured'
        });
      }

      try {
        const { bot } = await import('../bot/telegram-bot');

        const lang = investment.language || 'ru';

        const translations = {
          en: {
            title: '<b>NEW PAYMENT FOR VERIFICATION</b>',
            userInfo: '<b>User Info:</b>',
            investmentInfo: '<b>Investment Info:</b>',
            plan: 'Plan',
            amount: 'Amount',
            adminWallet: '<b>Admin wallet:</b>',
            senderWallet: '<b>Sender wallet:</b>',
            requestDate: '<b>Request date:</b>',
            checkFunds: 'Check if funds received in wallet and approve or decline the request:',
            buttonApprove: 'Approve',
            buttonReject: 'Reject'
          },
          ru: {
            title: '<b>–ù–û–í–ê–Ø –û–ü–õ–ê–¢–ê –ù–ê –ü–†–û–í–ï–†–ö–£</b>',
            userInfo: '<b>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ:</b>',
            investmentInfo: '<b>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏:</b>',
            plan: '–ü–ª–∞–Ω',
            amount: '–°—É–º–º–∞',
            adminWallet: '<b>–ö–æ—à–µ–ª—ë–∫ –∞–¥–º–∏–Ω–∞:</b>',
            senderWallet: '<b>–ö–æ—à–µ–ª—ë–∫ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è:</b>',
            requestDate: '<b>–î–∞—Ç–∞ –∑–∞—è–≤–∫–∏:</b>',
            checkFunds: '–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ—Å—Ç—É–ø–ª–µ–Ω–∏–µ —Å—Ä–µ–¥—Å—Ç–≤ –Ω–∞ –∫–æ—à–µ–ª—ë–∫ –∏ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –∏–ª–∏ –æ—Ç–∫–ª–æ–Ω–∏—Ç–µ –∑–∞—è–≤–∫—É:',
            buttonApprove: '–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å',
            buttonReject: '–û—Ç–∫–ª–æ–Ω–∏—Ç—å'
          }
        };

        const t = translations[lang as 'en' | 'ru'] || translations.ru;

        const currentTime = new Date().toLocaleString('ru-RU', {
          timeZone: 'Europe/Moscow',
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        });

        const supportMessage = `
${t.title}

${t.userInfo}
User ID: <code>${investment.userId}</code>
Email: <code>${investment.user.email || 'N/A'}</code>

${t.investmentInfo}
Investment ID: <code>${investmentId}</code>
${t.plan}: ${investment.plan.name}
${t.amount}: <b>${Number(investment.amount).toFixed(2)} USDT (TRC-20)</b>

${t.adminWallet}
<code>${adminWallet}</code>

${t.senderWallet}
<code>${investment.userWalletAddress}</code>

${t.requestDate} ${currentTime}

${t.checkFunds}
        `.trim();

        await bot.sendMessage(ADMIN_CHAT_ID, supportMessage, {
          parse_mode: 'HTML',
          reply_markup: {
            inline_keyboard: [
              [
                { text: t.buttonApprove, callback_data: `approve_${investmentId}_0` },
                { text: t.buttonReject, callback_data: `reject_${investmentId}_0` }
              ]
            ]
          }
        });

        console.log('Telegram notification sent to admin for investment:', investmentId);

      } catch (telegramError) {
        console.error('Failed to send Telegram notification:', telegramError);
        return reply.status(500).send({
          success: false,
          error: 'Failed to notify administrator'
        });
      }

      await prisma.auditLog.create({
        data: {
          userId,
          action: 'PAYMENT_CONFIRMATION_SENT',
          resource: 'INVESTMENT',
          details: JSON.stringify({
            investmentId: investment.id,
            planName: investment.plan.name,
            amount: investment.amount.toString(),
            duration: investment.duration,
            userWalletAddress: investment.userWalletAddress,
            adminWalletAddress: adminWallet
          }),
          ipAddress: request.ip,
          success: true
        }
      });

      return reply.send({
        success: true,
        message: 'Payment confirmation sent to administrator. You will be notified within 30 minutes.',
        data: {
          investmentId: investment.id,
          status: 'PENDING',
          expectedResponseTime: '30 minutes'
        }
      });

    } catch (error: any) {
      console.error('Confirm payment error:', error);
      request.log.error(error);
      return reply.status(500).send({
        success: false,
        error: 'Failed to process payment confirmation'
      });
    }
  });
  
  app.post('/:id/upgrade', async (request, reply) => {
    try {
      const { id } = request.params as { id: string };
      const { 
        upgradeType,
        additionalAmount, 
        newPackage, 
        newDuration,
        paymentMethod, 
        senderWalletAddress 
      } = request.body as {
        upgradeType: 'amount' | 'duration';
        additionalAmount?: number;
        newPackage?: string;
        newDuration?: number;
        paymentMethod: string;
        senderWalletAddress: string;
      };
      
      const userId = request.currentUser!.id;

      console.log('üìà Upgrade request:', { 
        investmentId: id, 
        userId, 
        upgradeType, 
        additionalAmount, 
        newPackage,
        newDuration 
      });

      const investment = await prisma.investment.findFirst({
        where: {
          id,
          userId,
          status: 'ACTIVE'
        },
        include: {
          plan: true,
          user: {
            select: {
              email: true,
              username: true
            }
          }
        }
      });

      if (!investment) {
        return reply.code(404).send({
          success: false,
          error: 'Investment not found or not active'
        });
      }

      const existingPendingUpgrade = await prisma.investmentUpgrade.findFirst({
        where: {
          investmentId: id,
          status: 'PENDING'
        }
      });

      if (existingPendingUpgrade) {
        return reply.code(400).send({
          success: false,
          error: 'Pending upgrade already exists'
        });
      }

      if (upgradeType === 'amount' && investment.lastUpgradeDate) {
        const lastUpgrade = new Date(investment.lastUpgradeDate);
        const today = new Date();
        const isSameDay = 
          lastUpgrade.getFullYear() === today.getFullYear() &&
          lastUpgrade.getMonth() === today.getMonth() &&
          lastUpgrade.getDate() === today.getDate();
        
        if (isSameDay) {
          return reply.code(400).send({
            success: false,
            error: 'Cannot upgrade twice in the same day'
          });
        }
      }

      if (upgradeType === 'amount') {
        const trc20Regex = /^T[A-Za-z1-9]{33}$/;
        if (!senderWalletAddress || !trc20Regex.test(senderWalletAddress)) {
          return reply.code(400).send({
            success: false,
            error: 'Invalid TRC-20 address format'
          });
        }
      }

      const now = new Date();
      let baseDate = investment.lastUpgradeDate || investment.startDate!;
      const daysPassed = Math.floor((now.getTime() - baseDate.getTime()) / (1000 * 60 * 60 * 24));
      const monthlyRate = Number(investment.effectiveROI);
      const dailyRate = monthlyRate / 30;
      const currentReturn = (Number(investment.amount) * dailyRate * daysPassed) / 100;
      const accumulatedInterest = Number(investment.accumulatedInterest || 0);
      const totalAccumulated = currentReturn + accumulatedInterest;

      const adminWalletConfig = await prisma.systemConfig.findUnique({
        where: { key: 'STAKING_WALLET_USDT_TRC20' }
      });

      const adminWallet = adminWalletConfig?.value || process.env.ADMIN_WALLET_ADDRESS || '';

      if (!adminWallet) {
        console.error('Admin wallet not configured for upgrade');
        return reply.code(500).send({
          success: false,
          error: 'Admin wallet configuration missing'
        });
      }

      console.log('üí≥ Admin wallet retrieved:', adminWallet);

      if (upgradeType === 'amount') {
        if (!additionalAmount || !newPackage) {
          return reply.code(400).send({
            success: false,
            error: 'Missing additionalAmount or newPackage for amount upgrade'
          });
        }

        const packages: Record<string, { name: string; monthlyRate: number }> = {
          'Starter': { name: 'Starter', monthlyRate: 14 },
          'Advanced': { name: 'Advanced', monthlyRate: 17 },
          'Pro': { name: 'Pro', monthlyRate: 20 },
          'Elite': { name: 'Elite', monthlyRate: 22 }
        };

        const targetPkg = packages[newPackage];
        if (!targetPkg) {
          return reply.code(400).send({
            success: false,
            error: 'Invalid package'
          });
        }

        const newAmount = Number(investment.amount) + additionalAmount;
        
        const durationBonuses: Record<number, number> = {
          3: 0,
          6: 1.5,
          12: 3
        };
        
        const newDurationBonus = durationBonuses[investment.duration] || 0;
        const newEffectiveROI = targetPkg.monthlyRate + newDurationBonus;

        const upgradeCost = additionalAmount;

        console.log('üí∞ Amount upgrade:', {
          oldAmount: Number(investment.amount),
          additionalAmount,
          newAmount,
          oldROI: Number(investment.effectiveROI),
          newROI: newEffectiveROI,
          baseRate: targetPkg.monthlyRate,
          durationBonus: newDurationBonus
        });

        console.log('üí≥ Upgrade wallets:', {
          adminWallet,
          senderWallet: senderWalletAddress.trim()
        });

        const upgradeData = {
          investmentId: id,
          userId,
          upgradeType: 'amount',
          oldPackage: investment.plan.name,
          newPackage: newPackage,
          oldAPY: investment.effectiveROI,
          newAPY: newEffectiveROI,
          additionalAmount: additionalAmount,
          oldDuration: investment.duration,
          newDuration: investment.duration,
          oldEndDate: investment.endDate!,
          newEndDate: investment.endDate!,
          accumulatedInterest: totalAccumulated,
          adminWalletAddress: adminWallet,
          senderWalletAddress: senderWalletAddress.trim(),
          status: 'PENDING',
          requestDate: now
        };

        const upgrade = await prisma.investmentUpgrade.create({
          data: upgradeData
        });

        await prisma.auditLog.create({
          data: {
            userId,
            action: 'UPGRADE_REQUEST',
            resource: 'INVESTMENT',
            details: JSON.stringify({
              investmentId: id,
              upgradeId: upgrade.id,
              upgradeType: 'amount',
              oldPackage: upgrade.oldPackage,
              newPackage: upgrade.newPackage,
              oldAPY: upgrade.oldAPY.toString(),
              newAPY: upgrade.newAPY.toString(),
              additionalAmount: upgrade.additionalAmount?.toString() || '0',
              accumulatedInterest: totalAccumulated,
              newAmount,
              newDurationBonus,
              adminWallet,
              senderWalletAddress
            }),
            ipAddress: request.ip,
            success: true
          }
        });

        const responseData = {
          success: true,
          message: 'Upgrade request created successfully',
          data: {
            upgradeId: upgrade.id,
            upgradeType: 'amount',
            oldPackage: upgrade.oldPackage,
            newPackage: upgrade.newPackage,
            oldAPY: Number(upgrade.oldAPY),
            newAPY: Number(upgrade.newAPY),
            additionalAmount: Number(upgrade.additionalAmount || 0),
            upgradeCost: upgradeCost,
            newAmount: newAmount,
            accumulatedInterest: totalAccumulated,
            rateBonus: newDurationBonus,
            adminWallet: adminWallet,
            senderWallet: senderWalletAddress.trim(),
            status: 'PENDING'
          }
        };

        console.log('üì§ RESPONSE TO FRONTEND (amount):', JSON.stringify(responseData, null, 2));
        return reply.send(responseData);
      } 
      else if (upgradeType === 'duration') {
        if (!newDuration) {
          return reply.code(400).send({
            success: false,
            error: 'Missing newDuration for duration upgrade'
          });
        }

        if (newDuration <= investment.duration) {
          return reply.code(400).send({
            success: false,
            error: 'New duration must be greater than current duration'
          });
        }

        const currentAmount = Number(investment.amount);

        const durationBonuses: Record<number, number> = {
          3: 0,
          6: 1.5,
          12: 3
        };

        const newDurationBonus = durationBonuses[newDuration] || 0;
        const baseROI = Number(investment.roi);
        const newEffectiveROI = baseROI + newDurationBonus;

        const oldEndDate = new Date(investment.endDate!);
        const additionalMonths = newDuration - investment.duration;
        const newEndDate = new Date(oldEndDate);
        newEndDate.setMonth(newEndDate.getMonth() + additionalMonths);

        console.log('‚è∞ Duration upgrade:', {
          oldDuration: investment.duration,
          newDuration,
          baseROI,
          oldDurationBonus: Number(investment.durationBonus),
          newDurationBonus,
          oldEffectiveROI: Number(investment.effectiveROI),
          newEffectiveROI,
          oldEndDate: investment.endDate,
          newEndDate
        });

        try {
          const updatedInvestment = await prisma.investment.update({
            where: { id },
            data: {
              duration: newDuration,
              durationBonus: newDurationBonus,
              effectiveROI: newEffectiveROI,
              endDate: newEndDate,
              lastUpgradeDate: now,
              accumulatedInterest: totalAccumulated
            }
          });

          const upgradeRecord = await prisma.investmentUpgrade.create({
            data: {
              investmentId: id,
              userId,
              upgradeType: 'duration',
              oldPackage: investment.plan.name,
              newPackage: investment.plan.name,
              oldAPY: investment.effectiveROI,
              newAPY: newEffectiveROI,
              additionalAmount: null,
              oldDuration: investment.duration,
              newDuration: newDuration,
              oldEndDate: investment.endDate!,
              newEndDate: newEndDate,
              accumulatedInterest: totalAccumulated,
              status: 'COMPLETED',
              requestDate: now,
              processedDate: now
            }
          });

          await prisma.auditLog.create({
            data: {
              userId,
              action: 'DURATION_UPGRADE_COMPLETED',
              resource: 'INVESTMENT',
              details: JSON.stringify({
                investmentId: id,
                upgradeId: upgradeRecord.id,
                upgradeType: 'duration',
                oldDuration: investment.duration,
                newDuration,
                oldAPY: Number(investment.effectiveROI),
                newAPY: newEffectiveROI,
                oldDurationBonus: Number(investment.durationBonus),
                newDurationBonus,
                accumulatedInterest: totalAccumulated,
                autoApplied: true
              }),
              ipAddress: request.ip,
              success: true
            }
          });

          console.log('‚úÖ Duration upgrade applied successfully:', {
            upgradeId: upgradeRecord.id,
            newDuration,
            baseROI,
            newDurationBonus: `+${newDurationBonus}%`,
            oldEffectiveROI: Number(investment.effectiveROI),
            newEffectiveROI,
            effectiveROI_updated: true
          });

          const responseData = {
            success: true,
            message: 'Duration upgrade completed successfully',
            data: {
              upgradeId: upgradeRecord.id,
              upgradeType: 'duration',
              oldDuration: investment.duration,
              newDuration,
              oldAPY: Number(investment.effectiveROI),
              newAPY: newEffectiveROI,
              rateBonus: newDurationBonus,
              newEndDate: newEndDate.toISOString(),
              accumulatedInterest: totalAccumulated,
              adminWallet: adminWallet,
              senderWallet: senderWalletAddress || '',
              status: 'COMPLETED',
              appliedImmediately: true
            }
          };

          console.log('üì§ RESPONSE TO FRONTEND (duration):', JSON.stringify(responseData, null, 2));
          return reply.send(responseData);

        } catch (upgradeError: any) {
          console.error('‚ùå Duration upgrade error:', upgradeError);
          return reply.code(500).send({
            success: false,
            error: 'Failed to apply duration upgrade'
          });
        }

      } else {
        return reply.code(400).send({
          success: false,
          error: 'Invalid upgradeType. Must be "amount" or "duration"'
        });
      }

    } catch (error: any) {
      console.error('‚ùå Upgrade error:', error);
      request.log.error(error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to process upgrade request'
      });
    }
  });

  app.post('/upgrade/:upgradeId/confirm-payment', async (request, reply) => {
    try {
      const { upgradeId } = request.params as { upgradeId: string };
      const userId = request.currentUser!.id;

      console.log('üîî Upgrade payment confirmation request:', { upgradeId, userId });

      const upgrade = await prisma.investmentUpgrade.findUnique({
        where: { id: upgradeId },
        include: {
          investment: {
            include: {
              plan: true,
              user: {
                select: {
                  email: true,
                  username: true
                }
              }
            }
          }
        }
      });

      if (!upgrade) {
        return reply.status(404).send({
          success: false,
          error: 'Upgrade not found'
        });
      }

      if (upgrade.userId !== userId) {
        return reply.status(403).send({
          success: false,
          error: 'Access denied'
        });
      }

      if (upgrade.status !== 'PENDING') {
        return reply.status(400).send({
          success: false,
          error: 'Upgrade is not in pending status'
        });
      }

      if (upgrade.upgradeType !== 'amount') {
        return reply.status(400).send({
          success: false,
          error: 'Only amount upgrades require payment confirmation'
        });
      }

      const oldAmount = Number(upgrade.investment.amount);
      const additionalAmount = Number(upgrade.additionalAmount || 0);
      const totalAmount = oldAmount + additionalAmount;

      console.log('üí∞ Upgrade payment details:', {
        upgradeId: upgrade.id,
        oldPackage: upgrade.oldPackage,
        newPackage: upgrade.newPackage,
        oldAmount,
        additionalAmount,
        totalAmount,
        adminWallet: upgrade.adminWalletAddress,
        senderWallet: upgrade.senderWalletAddress
      });

      try {
        await notifyUpgradeRequest({
          upgradeId: upgrade.id,
          investmentId: upgrade.investmentId,
          userId: userId,
          userEmail: upgrade.investment.user.email || 'N/A',
          oldPackage: upgrade.oldPackage,
          newPackage: upgrade.newPackage,
          oldAPY: Number(upgrade.oldAPY),
          newAPY: Number(upgrade.newAPY),
          oldAmount: oldAmount,
          additionalAmount: additionalAmount,
          totalAmount: totalAmount,
          adminWallet: upgrade.adminWalletAddress || '',
          senderWallet: upgrade.senderWalletAddress || '',
          language: upgrade.investment.language || 'ru'
        });

        console.log('‚úÖ Upgrade Telegram notification sent to admin:', upgrade.id);
      } catch (telegramError) {
        console.error('‚ö†Ô∏è Failed to send Telegram notification for upgrade:', telegramError);
        return reply.status(500).send({
          success: false,
          error: 'Failed to notify administrator'
        });
      }

      await prisma.auditLog.create({
        data: {
          userId,
          action: 'UPGRADE_PAYMENT_CONFIRMATION_SENT',
          resource: 'INVESTMENT',
          details: JSON.stringify({
            upgradeId: upgrade.id,
            investmentId: upgrade.investmentId,
            upgradeType: upgrade.upgradeType,
            oldPackage: upgrade.oldPackage,
            newPackage: upgrade.newPackage,
            additionalAmount: additionalAmount.toString(),
            totalAmount: totalAmount.toString(),
            adminWalletAddress: upgrade.adminWalletAddress,
            senderWalletAddress: upgrade.senderWalletAddress
          }),
          ipAddress: request.ip,
          success: true
        }
      });

      return reply.send({
        success: true,
        message: 'Payment confirmation sent to administrator. You will be notified within 30 minutes.',
        data: {
          upgradeId: upgrade.id,
          status: 'PENDING',
          expectedResponseTime: '30 minutes'
        }
      });

    } catch (error: any) {
      console.error('‚ùå Upgrade confirm payment error:', error);
      request.log.error(error);
      return reply.status(500).send({
        success: false,
        error: 'Failed to process upgrade payment confirmation'
      });
    }
  });

  app.post('/:id/early-withdraw', async (request, reply) => {
    try {
      const { id } = request.params as { id: string };
      const { trc20Address } = request.body as { trc20Address: string };
      const userId = request.currentUser!.id;

      console.log('‚ö° Early withdrawal request:', { investmentId: id, userId, trc20Address });

      const trc20Regex = /^T[A-Za-z1-9]{33}$/;
      if (!trc20Address || !trc20Regex.test(trc20Address)) {
        return reply.code(400).send({
          success: false,
          error: 'Invalid TRC-20 address format'
        });
      }

      const investment = await prisma.investment.findFirst({
        where: {
          id,
          userId,
          status: 'ACTIVE'
        },
        include: {
          plan: true,
          user: {
            select: {
              email: true,
              username: true
            }
          }
        }
      });

      if (!investment) {
        return reply.code(404).send({
          success: false,
          error: 'Investment not found or not active'
        });
      }

      const createdDate = new Date(investment.createdAt);
      const now = new Date();
      const totalDaysPassed = Math.floor((now.getTime() - createdDate.getTime()) / (1000 * 60 * 60 * 24));

      console.log('‚è∞ Early withdrawal check:', {
        createdAt: createdDate.toISOString(),
        now: now.toISOString(),
        totalDaysPassed,
        limit: 30
      });

      if (totalDaysPassed > 30) {
        return reply.code(400).send({
          success: false,
          error: 'Early withdrawal is only available within the first 30 days from investment creation'
        });
      }

      let baseDate = investment.lastUpgradeDate || investment.startDate!;
      const daysSinceBase = Math.floor((now.getTime() - baseDate.getTime()) / (1000 * 60 * 60 * 24));

      const monthlyRate = Number(investment.effectiveROI);
      const dailyRate = monthlyRate / 30;
      const earnedInterest = (Number(investment.amount) * dailyRate * daysSinceBase) / 100;
      const accumulatedInterest = Number(investment.accumulatedInterest || 0);
      const totalEarned = earnedInterest + accumulatedInterest;
      const withdrawnProfits = Number(investment.withdrawnProfits || 0);
      const totalAmount = Number(investment.amount) - withdrawnProfits;

      console.log('üí∞ Early withdrawal calculation:', {
        baseDate: baseDate.toISOString(),
        daysSinceBase,
        earnedInterest,
        accumulatedInterest,
        totalEarned,
        withdrawnProfits,
        totalAmount
      });

      const earlyWithdrawal = await prisma.earlyWithdrawal.create({
        data: {
          investmentId: investment.id,
          userId: userId,
          investmentAmount: investment.amount,
          daysInvested: totalDaysPassed,
          earnedInterest: totalEarned,
          withdrawnProfits: withdrawnProfits,
          totalAmount: totalAmount,
          trc20Address: trc20Address.trim(),
          status: 'PENDING'
        }
      });

      const BOT_USERNAME = process.env.TELEGRAM_BOT_USERNAME || 'dxcapital_bot';
      const botLink = `https://t.me/${BOT_USERNAME}?start=early_${earlyWithdrawal.id}`;

      try {
        await notifyEarlyWithdrawal({
          withdrawalId: earlyWithdrawal.id,
          investmentId: investment.id,
          userId: userId,
          userEmail: investment.user.email || 'N/A',
          planName: investment.plan.name,
          investmentAmount: Number(investment.amount),
          earnedInterest: totalEarned,
          withdrawnProfits: withdrawnProfits,
          totalAmount: totalAmount,
          daysInvested: totalDaysPassed,
          trc20Address: trc20Address.trim(),
          language: investment.language || 'ru'
        });

        console.log('‚úÖ Telegram notification sent to admin for early withdrawal:', earlyWithdrawal.id);
      } catch (telegramError) {
        console.error('‚ö†Ô∏è Failed to send Telegram notification:', telegramError);
      }

      await prisma.auditLog.create({
        data: {
          userId,
          action: 'EARLY_WITHDRAWAL_REQUEST',
          resource: 'INVESTMENT',
          details: JSON.stringify({
            investmentId: id,
            earlyWithdrawalId: earlyWithdrawal.id,
            investmentAmount: investment.amount.toString(),
            totalDaysPassed,
            daysInvested: totalDaysPassed,
            earnedInterest: totalEarned,
            withdrawnProfits: withdrawnProfits,
            totalAmount: totalAmount,
            trc20Address,
            planName: investment.plan.name,
            botLink
          }),
          ipAddress: request.ip,
          success: true
        }
      });

      return reply.send({
        success: true,
        message: 'Early withdrawal request created. Admin will review your request shortly.',
        data: {
          earlyWithdrawalId: earlyWithdrawal.id,
          investmentAmount: Number(investment.amount),
          earnedInterest: totalEarned,
          withdrawnProfits: withdrawnProfits,
          totalAmount: totalAmount,
          daysInvested: totalDaysPassed,
          status: 'PENDING',
          botLink,
          note: 'Earned interest is forfeited as penalty for early withdrawal'
        }
      });

    } catch (error: any) {
      console.error('‚ùå Early withdrawal error:', error);
      request.log.error(error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to process early withdrawal'
      });
    }
  });

  app.post('/:id/partial-withdraw', async (request, reply) => {
    try {
      const { id } = request.params as { id: string };
      const { trc20Address, withdrawType } = request.body as { 
        trc20Address: string;
        withdrawType: 'profit' | 'bonus';
      };
      const userId = request.currentUser!.id;

      console.log('üí∞ Withdrawal request:', { 
        investmentId: id, 
        userId, 
        withdrawType, 
        trc20Address 
      });

      if (!withdrawType || !['profit', 'bonus'].includes(withdrawType)) {
        return reply.code(400).send({
          success: false,
          error: 'Invalid withdrawType. Must be "profit" or "bonus"'
        });
      }

      const trc20Regex = /^T[A-Za-z1-9]{33}$/;
      if (!trc20Address || !trc20Regex.test(trc20Address)) {
        return reply.code(400).send({
          success: false,
          error: 'Invalid TRC-20 address format'
        });
      }

      const investment = await prisma.investment.findFirst({
        where: {
          id,
          userId,
          status: 'ACTIVE'
        },
        include: {
          plan: true,
          user: {
            select: {
              email: true,
              username: true
            }
          }
        }
      });

      if (!investment) {
        return reply.code(404).send({
          success: false,
          error: 'Investment not found or not active'
        });
      }

      let withdrawalAmount = 0;
      let description = '';
      let withdrawalType = '';

      if (withdrawType === 'profit') {
        console.log('üîç Profit withdrawal - dates DEBUG:', {
          investmentId: investment.id,
          startDate: investment.startDate,
          lastUpgradeDate: investment.lastUpgradeDate,
          createdAt: investment.createdAt,
          accumulatedInterest: investment.accumulatedInterest,
          withdrawnProfits: investment.withdrawnProfits
        });

        const now = new Date();
        let baseDate: Date;
        
        if (investment.lastUpgradeDate) {
          baseDate = new Date(investment.lastUpgradeDate);
          console.log('‚úÖ Using lastUpgradeDate as base');
        } else if (investment.startDate) {
          baseDate = new Date(investment.startDate);
          console.log('‚úÖ Using startDate as base');
        } else {
          baseDate = new Date(investment.createdAt);
          console.log('‚úÖ Using createdAt as base');
        }
        
        const daysPassed = Math.floor((now.getTime() - baseDate.getTime()) / (1000 * 60 * 60 * 24));
        const monthlyRate = Number(investment.effectiveROI);
        const dailyRate = monthlyRate / 30;
        const newPeriodProfit = (Number(investment.amount) * dailyRate * daysPassed) / 100;
        const accumulatedInterest = Number(investment.accumulatedInterest || 0);
        const totalProfit = newPeriodProfit + accumulatedInterest;
        const withdrawnProfits = Number(investment.withdrawnProfits || 0);
        const availableProfit = Math.max(0, totalProfit - withdrawnProfits);

        console.log('üìä Profit calculation:', {
          baseDate: baseDate.toISOString(),
          daysPassed,
          dailyRate: `${dailyRate.toFixed(4)}%`,
          newPeriodProfit: newPeriodProfit.toFixed(2),
          accumulatedInterest: accumulatedInterest.toFixed(2),
          totalProfit: totalProfit.toFixed(2),
          withdrawnProfits: withdrawnProfits.toFixed(2),
          availableProfit: availableProfit.toFixed(2)
        });

        if (availableProfit <= 0) {
          return reply.code(400).send({
            success: false,
            error: 'No profit available for withdrawal'
          });
        }

        withdrawalAmount = availableProfit;
        description = 'Partial profit withdrawal';
        withdrawalType = 'PROFIT';

      } else if (withdrawType === 'bonus') {
        function getDurationBonus(duration: number, amount: number): number {
          if (duration === 3) return 0;
          if (duration === 6 || duration === 12) {
            if (amount >= 1000) return 500;
            if (amount >= 500) return 200;
          }
          return 0;
        }

        const bonusAmount = getDurationBonus(investment.duration, Number(investment.amount));

        console.log('üéÅ Bonus withdrawal - validation:', {
          bonusAmount,
          duration: investment.duration,
          amount: Number(investment.amount),
          createdAt: investment.createdAt,
          bonusWithdrawn: investment.bonusWithdrawn
        });

        if (bonusAmount <= 0) {
          return reply.code(400).send({
            success: false,
            error: 'No bonus available for this investment'
          });
        }

        if (investment.duration < 6) {
          return reply.code(400).send({
            success: false,
            error: 'Bonus is only available for investments created for 6 or 12 months'
          });
        }

        if (investment.bonusWithdrawn) {
          return reply.code(400).send({
            success: false,
            error: 'Bonus has already been withdrawn'
          });
        }

        const now = new Date();
        const createdAt = new Date(investment.createdAt);
        const daysPassed = Math.floor((now.getTime() - createdAt.getTime()) / (1000 * 60 * 60 * 24));
        const halfDurationDays = (investment.duration / 2) * 30;
        
        console.log('üîç Bonus unlock check:', {
          duration: investment.duration,
          createdAt: createdAt.toISOString(),
          now: now.toISOString(),
          daysPassed,
          halfDurationDays,
          isUnlocked: daysPassed >= halfDurationDays
        });

        if (daysPassed < halfDurationDays) {
          const daysRemaining = Math.ceil(halfDurationDays - daysPassed);
          return reply.code(400).send({
            success: false,
            error: `Bonus will be available after ${Math.ceil(investment.duration / 2)} months (${daysRemaining} days remaining)`
          });
        }

        console.log('‚úÖ Bonus available for withdrawal:', {
          bonusAmount,
          daysPassed,
          halfDurationDays,
          daysOverHalf: daysPassed - halfDurationDays
        });

        withdrawalAmount = bonusAmount;
        description = 'Duration bonus withdrawal';
        withdrawalType = 'BONUS';
      }

      const withdrawal = await prisma.partialWithdrawal.create({
        data: {
          investmentId: investment.id,
          userId: userId,
          amount: withdrawalAmount,
          trc20Address: trc20Address.trim(),
          status: 'PENDING'
        }
      });

      if (withdrawType === 'bonus') {
        await prisma.investment.update({
          where: { id },
          data: { bonusWithdrawn: true }
        });
      }

      const BOT_USERNAME = process.env.TELEGRAM_BOT_USERNAME || 'dxcapital_bot';
      const botLink = `https://t.me/${BOT_USERNAME}?start=partial_${withdrawal.id}`;

      try {
        await notifyPartialWithdrawal({
          withdrawalId: withdrawal.id,
          investmentId: investment.id,
          userId: userId,
          userEmail: investment.user.email || 'N/A',
          planName: investment.plan.name,
          investmentAmount: Number(investment.amount),
          amount: withdrawalAmount,
          totalWithdrawn: Number(investment.withdrawnProfits || 0) + withdrawalAmount,
          trc20Address: trc20Address.trim(),
          language: investment.language || 'ru'
        });

        console.log('‚úÖ Telegram notification sent to admin for partial withdrawal:', withdrawal.id);
      } catch (telegramError) {
        console.error('‚ö†Ô∏è Failed to send Telegram notification:', telegramError);
      }

      await prisma.auditLog.create({
        data: {
          userId,
          action: `WITHDRAWAL_REQUEST_${withdrawType.toUpperCase()}`,
          resource: 'INVESTMENT',
          details: JSON.stringify({
            investmentId: id,
            withdrawalId: withdrawal.id,
            withdrawType,
            amount: withdrawalAmount,
            trc20Address,
            planName: investment.plan.name,
            botLink
          }),
          ipAddress: request.ip,
          success: true
        }
      });

      console.log('‚úÖ Withdrawal request created (PENDING):', {
        withdrawalId: withdrawal.id,
        type: withdrawType,
        amount: withdrawalAmount,
        bonusWithdrawnFlag: withdrawType === 'bonus' ? true : undefined,
        note: 'Investment fields will be updated after admin approval'
      });

      return reply.send({
        success: true,
        message: `${withdrawType === 'profit' ? 'Profit' : 'Bonus'} withdrawal request created. Admin will review your request shortly.`,
        botLink: botLink,
        withdrawalId: withdrawal.id,
        data: {
          withdrawalId: withdrawal.id,
          type: withdrawalType,
          amount: withdrawalAmount,
          trc20Address: trc20Address.trim(),
          status: 'PENDING'
        }
      });

    } catch (error: any) {
      console.error('‚ùå Withdrawal error:', error);
      request.log.error(error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to process withdrawal request'
      });
    }
  });

  app.post('/:id/withdraw', async (request, reply) => {
    try {
      const { id } = request.params as { id: string };
      const { trc20Address } = request.body as { trc20Address: string };
      const userId = request.currentUser!.id;

      console.log('üè¶ Full withdrawal request:', { investmentId: id, userId, trc20Address });

      const trc20Regex = /^T[A-Za-z1-9]{33}$/;
      if (!trc20Address || !trc20Regex.test(trc20Address)) {
        return reply.code(400).send({
          success: false,
          error: 'Invalid TRC-20 address format'
        });
      }

      const investment = await prisma.investment.findFirst({
        where: {
          id,
          userId
        },
        include: {
          plan: true,
          user: {
            select: {
              email: true,
              username: true
            }
          }
        }
      });

      if (!investment) {
        return reply.code(404).send({
          success: false,
          error: 'Investment not found'
        });
      }

      console.log('‚úÖ Investment found:', {
        id: investment.id,
        amount: investment.amount,
        status: investment.status,
        duration: investment.duration,
        endDate: investment.endDate,
        withdrawalRequested: investment.withdrawalRequested
      });

      if (investment.withdrawalRequested) {
        return reply.code(400).send({
          success: false,
          error: 'Withdrawal already requested for this investment'
        });
      }

      const now = new Date();
      let baseDate = investment.lastUpgradeDate || investment.startDate!;
      const daysPassed = Math.floor((now.getTime() - baseDate.getTime()) / (1000 * 60 * 60 * 24));
      
      const monthlyRate = Number(investment.effectiveROI);
      const dailyRate = monthlyRate / 30;
      const earnedProfit = (Number(investment.amount) * dailyRate * daysPassed) / 100;
      const accumulatedInterest = Number(investment.accumulatedInterest || 0);
      const totalProfit = earnedProfit + accumulatedInterest;
      const withdrawnProfits = Number(investment.withdrawnProfits || 0);
      const availableProfit = totalProfit - withdrawnProfits;

      const investmentEndDate = new Date(investment.endDate!);
      const isInvestmentComplete = now >= investmentEndDate;

      console.log('‚è∞ Investment timeline:', {
        now: now.toISOString(),
        endDate: investmentEndDate.toISOString(),
        isComplete: isInvestmentComplete,
        daysPassed,
        durationMonths: investment.duration
      });

      console.log('üí∞ Withdrawal calculation:', {
        investmentAmount: Number(investment.amount),
        earnedProfit: earnedProfit.toFixed(2),
        accumulatedInterest: accumulatedInterest.toFixed(2),
        totalProfit: totalProfit.toFixed(2),
        withdrawnProfits: withdrawnProfits.toFixed(2),
        availableProfit: availableProfit.toFixed(2),
        totalReturn: (Number(investment.amount) + availableProfit).toFixed(2)
      });

      if (!isInvestmentComplete) {
        const monthsPassed = daysPassed / 30;
        const MIN_MONTHS_FOR_WITHDRAWAL = investment.duration;

        if (monthsPassed < MIN_MONTHS_FOR_WITHDRAWAL) {
          const monthsRemaining = (MIN_MONTHS_FOR_WITHDRAWAL - monthsPassed).toFixed(1);
          return reply.code(400).send({
            success: false,
            error: `Full withdrawal available after ${MIN_MONTHS_FOR_WITHDRAWAL} months. ${monthsRemaining} months remaining.`
          });
        }
      }

      const totalReturnAmount = Number(investment.amount) + availableProfit;

      const withdrawal = await prisma.withdrawalRequest.create({
        data: {
          userId,
          investmentId: id,
          amount: totalReturnAmount,
          trc20Address: trc20Address.trim(),
          status: 'PENDING'
        }
      });

      await prisma.investment.update({
        where: { id },
        data: {
          withdrawalRequested: true,
          status: isInvestmentComplete ? 'COMPLETED' : investment.status
        }
      });

      try {
        const { notifyWithdrawalRequest } = await import('../bot/telegram-bot');
      
        const amountNum = Number(investment.amount);
        const profitNum = availableProfit;
      
        await notifyWithdrawalRequest({
          withdrawalId: withdrawal.id,
          investmentId: investment.id,
          userId: userId,
          userEmail: investment.user.email || 'N/A',
          planName: investment.plan.name,
          amount: totalReturnAmount,
          invested: amountNum,
          profit: profitNum,
          trc20Address: trc20Address.trim(),
          language: investment.language || 'en'
        });
      } catch (telegramError) {
        console.error('‚ö†Ô∏è Failed to send Telegram notification:', telegramError);
      }

      await prisma.auditLog.create({
        data: {
          userId,
          action: 'REQUEST_WITHDRAWAL',
          resource: 'WITHDRAWAL',
          details: JSON.stringify({
            investmentId: id,
            withdrawalId: withdrawal.id,
            amount: totalReturnAmount.toString(),
            investmentAmount: investment.amount.toString(),
            profit: availableProfit.toFixed(2),
            trc20Address,
            planName: investment.plan.name,
            isComplete: isInvestmentComplete
          }),
          ipAddress: request.ip,
          success: true
        }
      });

      return reply.send({
        success: true,
        message: 'Withdrawal request submitted successfully. Admin will review your request shortly.',
        data: {
          withdrawalId: withdrawal.id,
          amount: totalReturnAmount,
          investmentAmount: Number(investment.amount),
          profit: availableProfit,
          trc20Address,
          status: 'PENDING'
        }
      });

    } catch (error: any) {
      console.error('‚ùå Withdrawal request error:', error);
      request.log.error(error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to create withdrawal request'
      });
    }
  });

  app.get('/partial-withdrawals', async (request, reply) => {
    try {
      const userId = request.currentUser!.id;

      const partialWithdrawals = await prisma.partialWithdrawal.findMany({
        where: { userId },
        include: {
          investment: {
            include: {
              plan: true
            }
          }
        },
        orderBy: { requestDate: 'desc' }
      });

      return reply.send({
        success: true,
        data: partialWithdrawals.map(pw => ({
          id: pw.id,
          investmentId: pw.investmentId,
          amount: Number(pw.amount),
          trc20Address: pw.trc20Address,
          status: pw.status,
          txHash: pw.txHash,
          rejectionReason: pw.rejectionReason,
          requestDate: pw.requestDate,
          processedDate: pw.processedDate,
          completedDate: pw.completedDate,
          createdAt: pw.createdAt,
          investment: {
            planName: pw.investment?.plan?.name
          }
        }))
      });

    } catch (error: any) {
      console.error('‚ùå Error fetching partial withdrawals:', error);
      request.log.error(error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to fetch partial withdrawals'
      });
    }
  });

  app.get('/withdrawals', async (request, reply) => {
    try {
      const userId = request.currentUser!.id;

      const withdrawalRequests = await prisma.withdrawalRequest.findMany({
        where: { userId },
        include: {
          investment: {
            include: {
              plan: true
            }
          }
        },
        orderBy: { createdAt: 'desc' }
      });

      const earlyWithdrawals = await prisma.earlyWithdrawal.findMany({
        where: { userId },
        include: {
          investment: {
            include: {
              plan: true
            }
          }
        },
        orderBy: { requestDate: 'desc' }
      });

      const partialWithdrawals = await prisma.partialWithdrawal.findMany({
        where: { userId },
        include: {
          investment: {
            include: {
              plan: true
            }
          }
        },
        orderBy: { requestDate: 'desc' }
      });

      const allWithdrawals = [
        ...withdrawalRequests.map(wr => ({
          id: wr.id,
          type: 'WITHDRAWAL',
          investmentId: wr.investmentId,
          amount: Number(wr.amount),
          totalAmount: Number(wr.amount),
          status: wr.status,
          trc20Address: wr.trc20Address,
          createdAt: wr.createdAt,
          requestedAt: wr.createdAt,
          processedAt: wr.processedAt,
          isEarlyWithdrawal: false,
          isPartialWithdrawal: false,
          investment: {
            planName: wr.investment?.plan?.name
          }
        })),
        ...earlyWithdrawals.map(ew => ({
          id: ew.id,
          type: 'EARLY_WITHDRAWAL',
          investmentId: ew.investmentId,
          amount: Number(ew.totalAmount),
          totalAmount: Number(ew.totalAmount),
          investmentAmount: Number(ew.investmentAmount),
          earnedInterest: Number(ew.earnedInterest),
          withdrawnProfits: Number(ew.withdrawnProfits),
          daysInvested: ew.daysInvested,
          status: ew.status,
          trc20Address: ew.trc20Address,
          createdAt: ew.requestDate,
          requestedAt: ew.requestDate,
          processedAt: ew.processedDate,
          isEarlyWithdrawal: true,
          isPartialWithdrawal: false,
          investment: {
            planName: ew.investment?.plan?.name
          }
        })),
        ...partialWithdrawals.map(pw => ({
          id: pw.id,
          type: 'PARTIAL_WITHDRAWAL',
          investmentId: pw.investmentId,
          amount: Number(pw.amount),
          totalAmount: Number(pw.amount),
          status: pw.status,
          trc20Address: pw.trc20Address,
          txHash: pw.txHash,
          rejectionReason: pw.rejectionReason,
          createdAt: pw.requestDate,
          requestedAt: pw.requestDate,
          processedAt: pw.processedDate,
          completedAt: pw.completedDate,
          isEarlyWithdrawal: false,
          isPartialWithdrawal: true,
          investment: {
            planName: pw.investment?.plan?.name
          }
        }))
      ];

      allWithdrawals.sort((a, b) =>
        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      );

      return reply.send({
        success: true,
        data: allWithdrawals
      });

    } catch (error: any) {
      console.error('‚ùå Error fetching withdrawals:', error);
      request.log.error(error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to fetch withdrawals'
      });
    }
  });

  app.get('/early-withdrawals', async (request, reply) => {
    try {
      const userId = request.currentUser!.id;

      const earlyWithdrawals = await prisma.earlyWithdrawal.findMany({
        where: { userId },
        include: {
          investment: {
            include: {
              plan: true
            }
          }
        },
        orderBy: { requestDate: 'desc' }
      });

      return reply.send({
        success: true,
        data: earlyWithdrawals.map(ew => ({
          id: ew.id,
          investmentId: ew.investmentId,
          investmentAmount: Number(ew.investmentAmount),
          daysInvested: ew.daysInvested,
          earnedInterest: Number(ew.earnedInterest),
          withdrawnProfits: Number(ew.withdrawnProfits),
          totalAmount: Number(ew.totalAmount),
          trc20Address: ew.trc20Address,
          status: ew.status,
          requestDate: ew.requestDate,
          createdAt: ew.requestDate,
          processedDate: ew.processedDate,
          type: 'EARLY_WITHDRAWAL',
          isEarlyWithdrawal: true,
          investment: {
            planName: ew.investment?.plan?.name
          }
        }))
      });

    } catch (error: any) {
      console.error('‚ùå Error fetching early withdrawals:', error);
      request.log.error(error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to fetch early withdrawals'
      });
    }
  });

  app.get('/upgrades', async (request, reply) => {
    try {
      const userId = request.currentUser!.id;

      const upgrades = await prisma.investmentUpgrade.findMany({
        where: { userId },
        include: {
          investment: {
            include: {
              plan: true
            }
          }
        },
        orderBy: { requestDate: 'desc' }
      });

      return reply.send({
        success: true,
        data: upgrades.map(upgrade => ({
          id: upgrade.id,
          investmentId: upgrade.investmentId,
          upgradeType: upgrade.upgradeType,
          oldPackage: upgrade.oldPackage,
          newPackage: upgrade.newPackage,
          oldAPY: Number(upgrade.oldAPY),
          newAPY: Number(upgrade.newAPY),
          additionalAmount: Number(upgrade.additionalAmount || 0),
          oldDuration: upgrade.oldDuration,
          newDuration: upgrade.newDuration,
          oldEndDate: upgrade.oldEndDate,
          newEndDate: upgrade.newEndDate,
          adminWalletAddress: upgrade.adminWalletAddress,
          senderWalletAddress: upgrade.senderWalletAddress,
          accumulatedInterest: Number(upgrade.accumulatedInterest || 0),
          status: upgrade.status,
          requestDate: upgrade.requestDate,
          processedDate: upgrade.processedDate,
          createdAt: upgrade.createdDate
        }))
      });

    } catch (error: any) {
      console.error('‚ùå Error fetching upgrades:', error);
      request.log.error(error);
      return reply.code(500).send({
        success: false,
        error: 'Failed to fetch upgrades'
      });
    }
  });
}